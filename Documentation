20th May:

	Setting git-hub account , downloading git and learning about it ie. how to create repository , addition of files , adding them to stage area ,commit files,and to upload them to git-hub.

22nd May:
	Reading about operating system from Modern Operating System 2nd Ed By Tanebaum and Linux.Kernel.Development.3rd.Edition. I learned about kernel , process architecture, kernel tree, and basics of file system,shell and deadlocks. Also read about system calls,types:process management,file management,file system and miscelianeous.
	
24th May	
	Read about configuring linux and how to install it. It took hours to configure the new linux tree , and then after configuring it we installed it. Even after installing it when we rebooted ubuntu although it gave an option for booting with new kernel ,the new kernel was not loading.

26th May
	Reapeted attempts to boot with new kernel image but repeated failure.Boot loader showing error.

28th May
	Started reading more aggresively of System Calls. Started exploring system calls given below:

1) fork():
	
	This system call creates a child process. As this function is called from lets say "y" program then in parallel to the existing process a child process is also code which executes the program from below that "fork()" command.Now there are two process running in parallel one the parent one and other the child one. One may wonder what if let there are some variables defined earlier in the program and are used after the fork command then how will the child process will implement that variable....answer to this question is that when the child process is called it's memory address remains the same as parent but seperately spaced.

		eg: executing a simple code:

		#include <stdio.h>
		int main()
		{

 			int i;

 			i= fork();
 			if(i==0) printf("%d\tCHILD\n",i);
 			else printf("%d\tPARENT\n",i);
			return 0;
		}

	upon running this it generates the output:
	2387	PARENT
	0	CHILD

The fork() command returns the pid of child to parent and 0 to child.

2) access():

	This system call tells the permission status of a file for the process calling this system call. Whether file exits and if exits then status about read,write and execute permissions.If return value is 0 then positive result else fail.
	access(path,F_OK);  file existence
	access(path,R_OK);  readable
	access(path,W_OK);  writing
	access(path,X_OK);  executable

3) fcntl():

	This system call serves the purpose for locking files. They may be read locked or write locked.Read lock can be implemented by several process but write lock is only implemented by a single process. Suppose, a file is been read by manny users/process but a change can be made only by one at a time,if this is not so then it may create a havoc.
Set the l_type field of the structure to F_RDLCK for a read lock or F_WRLCK for a write lock.Then call fcntl, passing a file descriptor to the file, the F_SETLCKW operation code, and a pointer to the struct flock variable. If another process holds a lock that prevents a new lock from being acquired, fcntl blocks until that lock is released.

4) wait(&status):

	This system call waits for the child process to terminate and then execute parent process.When we simply use fork() the thing is processor decides itself which process to execute first but wait(&status) call execute child process first.

5) execve(file name,argv[],envp):

	Using this system call we can tell the file pointed by file name to execute using the argv[] as their variable entry.
